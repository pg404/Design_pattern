####1) 什么是线程？
线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。
程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。
比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。
Java在语言层面对多线程提供了卓越的支持，它也是一个很好的卖点.

####2) 线程和进程有什么区别？
线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。
不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。
别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。

####3) 如何在Java中实现线程？
在语言层面有两种方式。java.lang.Thread 类的实例就是一个线程,
但是它需要调用java.lang.Runnable接口来执行，由于线程类本身就是调用的Runnable接口,
所以你可以继承java.lang.Thread 类或者直接调用Runnable接口来重写run()方法实现线程。

####4) 用Runnable还是Thread？
这个问题是上题的后续，大家都知道我们可以通过继承Thread类或者调用Runnable接口来实现线程，
问题是，那个方法更好呢？什么情况下使用它？这个问题很容易回答，如果你知道Java不支持类的多重继承，
但允许你调用多个接口。所以如果你要继承其他类，当然是调用Runnable接口好了。

####5) Thread 类中的start() 和 run() 方法有什么区别？
这个问题经常被问到，但还是能从此区分出面试者对Java线程模型的理解程度。
start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，
这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，
没有新的线程启动，start()方法才会启动新线程。

####6) Java中Runnable和Callable有什么不同？
Runnable和Callable都代表那些要在不同的线程中执行的任务。Runnable从JDK1.0开始就有了，
Callable是在JDK1.5增加的。它们的主要区别是Callable的 call() 方法可以返回值和抛出异常，
而Runnable的run()方法没有这些功能。Callable可以返回装载有计算结果的Future对象。

####7) Java中CyclicBarrier 和 CountDownLatch有什么不同？
CyclicBarrier 和 CountDownLatch 都可以用来让一组线程等待其它线程。
与 CyclicBarrier 不同的是，CountdownLatch 不能重新使用。

####8) Java内存模型是什么？
Java内存模型规定和指引Java程序在不同的内存架构、CPU和操作系统间有确定性地行为。
它在多线程的情况下尤其重要。Java内存模型对一个线程所做的变动能被其它线程可见提供了保证，
它们之间是先行发生关系。这个关系定义了一些规则让程序员在并发编程时思路更清晰。比如，先行发生关系确保了：

线程内的代码能够按先后顺序执行，这被称为程序次序规则。
对于同一个锁，一个解锁操作一定要发生在时间上后发生的另一个锁定操作之前，也叫做管程锁定规则。
前一个对volatile的写操作在后一个volatile的读操作之前，也叫volatile变量规则。
一个线程内的任何操作必需在这个线程的start()调用之后，也叫作线程启动规则。
一个线程的所有操作都会在线程终止之前，线程终止规则。
一个对象的终结操作必需在这个对象构造完成之后，也叫对象终结规则。
可传递性
我强烈建议大家阅读《Java并发编程实践》第十六章来加深对Java内存模型的理解。

####9) Java中的volatile 变量是什么？
volatile是一个特殊的修饰符，只有成员变量才能使用它。在Java并发程序缺少同步类的情况下，
多线程对成员变量的操作对其它线程是透明的。volatile变量可以保证下一个读取操作会在前一个写操作之后发生，
就是上一题的volatile变量规则。

####10) 什么是线程安全？Vector是一个线程安全类吗？
如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。
如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，
就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。
很显然你可以将集合类分成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 
而和它相似的ArrayList不是线程安全的。