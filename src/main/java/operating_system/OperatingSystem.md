##操作系统

####1.死锁
所谓死锁，指的是两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，
如果无外力作用，那么它们都将无法推进下去。此时，称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程

[https://blog.csdn.net/weixin_39651041/article/details/79993975]

[https://blog.csdn.net/yanxiaolx/article/details/51944048]

#####产生死锁的原因
(1).系统资源不足  
(2).进程运行推进的顺序不合适  
(3).资源分配不当  

>如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。
其次，进程运行推进顺序与速度不同，也可能产生死锁。
一个线程也可引起死锁。


#####产生死锁的必要条件
（1） 互斥条件：一个资源每次只能被一个进程使用。

（2） 请求和保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

（3） 不可抢占条件:进程已获得的资源，在末使用完之前，不能强行剥夺，只能在进程使用完时由自己释放。

（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。

因此可以针对每一个必要条件写下如下的预防死锁的方法

#####预防死锁的方法

（1）破坏“互斥”条件:就是在系统里取消互斥。若资源不被一个进程独占使用，那么死锁是肯定不会发生的。
但一般“互斥”条件是无法破坏的。因此，在死锁预防里主要是破坏其他三个必要条件，而不去涉及破坏“互斥”条件。

（2）破坏“请求和保持”条件:在系统中不允许进程在已获得某种资源的情况下，申请其他资源。即要想出一个办法，阻止进程在持有资源的同时申请其他资源

   + 方法一：所有进程在运行之前，必须一次性地申请在整个运行过程中所需的全部资源。
    这样，该进程在整个运行期间，便不会再提出资源请求，从而破坏了“请求”条件。
    系统在分配资源时，只要有一种资源不能满足进程的要求，即使其它所需的各资源都空闲也不分配给该进程，而让该进程等待。
    由于该进程在等待期间未占有任何资源，于是破坏了“保持”条件。
    
      该方法优点：简单、易行且安全。
    
      缺点：a.资源被严重浪费，严重恶化了资源的利用率。
    
      b.使进程经常会发生饥饿现象。
    
   + 方法二：要求每个进程提出新的资源申请前，释放它所占有的资源。
    这样，一个进程在需要资源S时，须先把它先前占有的资源R释放掉，
    然后才能提出对S的申请，即使它可能很快又要用到资源R。

（3）破坏“不可抢占”条件：允许对资源实行抢夺。

+ 方法一：如果占有某些资源的一个进程进行进一步资源请求被拒绝，则该进程必须释放它最初占有的资源，如果有必要，可再次请求这些资源和另外的资源。
+ 方法二：如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另一个进程，要求它释放资源。
只有在任意两个进程的优先级都不相同的条件下，该方法才能预防死锁。

（4）破坏“循环等待”条件：将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序（升序）提出。
这样做就能保证系统不出现死锁


#####死锁的解除

一旦检测出死锁，就应立即釆取相应的措施，以解除死锁。死锁解除的主要两种方法：

1) 抢占资源。从一个或多个进程中抢占足够数量的资源，分配给死锁进程，以解除死锁状态。

2) 终止（或撤销）进程。终止（或撤销）系统中的一个或多个死锁进程，直至打破循环环路，使系统从死锁状态解脱出来

#####避免死锁的方法
一次封锁法：每个进程（事务）将所有要使用的数据全部加锁，否则，就不能继续执行；  
顺序封锁法：预先对数据对象规定一个封锁顺序，所有进程（事务）都按这个顺序加锁；  
银行家算法：保证进程处于安全进程序列。  

#####有助于最大限度地降低死锁的方法
按同一顺序访问对象；  
避免事务中的用户交互；  
保持事务简短并在一个批处理中；  
使用低隔离级别  

####2.操作系统的功能
+ 作业管理  
    任务管理、界面管理、人机交互、图形界面、语音控制、虚拟现实等
+ 文件管理  
    负责文件的存储、检索、共享和保护
+ 存储管理  
    对存储空间的管理
+ 设备管理  
    对硬件设备的管理
+ 进程管理  
    对处理器执行时间的管理


####3.进程调度算法

+ 时间片轮转调度算法（RR）：给每个进程固定的执行时间，根据进程到达的先后顺序让进程在单位时间片内执行，
执行完成后便调度下一个进程执行，时间片轮转调度不考虑进程等待时间和执行时间，属于抢占式调度。
优点是兼顾长短作业；缺点是平均等待时间较长，上下文切换较费时。适用于分时系统。
+ 先来先服务调度算法（FCFS）：根据进程到达的先后顺序执行进程，不考虑等待时间和执行时间，会产生饥饿现象。
属于非抢占式调度，优点是公平，实现简单；缺点是不利于短作业。
+ 优先级调度算法（HPF）：在进程等待队列中选择优先级最高的来执行。
+ 多级反馈队列调度算法：将时间片轮转与优先级调度相结合，把进程按优先级分成不同的队列，先按优先级调度，优先级相同的，
按时间片轮转。优点是兼顾长短作业，有较好的响应时间，可行性强，适用于各种作业环境。
+ 高响应比优先调度算法：根据“响应比=（进程执行时间+进程等待时间）/ 进程执行时间”这个公式得到的响应比来进行调度。
高响应比优先算法在等待时间相同的情况下，作业执行的时间越短，响应比越高，满足段任务优先，
同时响应比会随着等待时间增加而变大，优先级会提高，能够避免饥饿现象。优点是兼顾长短作业，缺点是计算响应比开销大，适用于批处理系统。



####4.分段与分页的区别

分页和分段有许多相似之处,比如两者都不要求作业连续存放.但在概念上两者完全不同,主要表现在以下几个方面:

(1)页是信息的物理单位,分页是为了实现非连续分配,以便解决内存碎片问题,或者说分页是由于系统管理的需要.
段是信息的逻辑单位,它含有一组意义相对完整的信息,分段的目的是为了更好地实现共享,满足用户的需要.

(2)页的大小固定,由系统确定,将逻辑地址划分为页号和页内地址是由机器硬件实现的.
而段的长度却不固定,决定于用户所编写的程序,通常由编译程序在对源程序进行编译时根据信息的性质来划分.

(3)分页的作业地址空间是一维的.分段的地址空间是二维的

>打个比方，比如说你去听课，带了一个纸质笔记本做笔记。笔记本有100张纸，课程有语文、数学、英语三门，
对于这个笔记本的使用，为了便于以后复习方便，你可以有两种选择。
 
>第一种是，你从本子的第一张纸开始用，并且事先在本子上做划分：第2张到第30张纸记语文笔记，
第31到60张纸记数学笔记，第61到100张纸记英语笔记，最后在第一张纸做个列表，记录着三门笔记各自的范围。这就是分段管理，第一张纸叫段表。
 
>第二种是，你从第二张纸开始做笔记，各种课的笔记是连在一起的：第2张纸是数学，第3张是语文，第4张英语……
最后呢，你在第一张纸做了一个目录，记录着语文笔记在第3、7、14、15张纸……，数学笔记在第2、6、8、9、11……，英语笔记在第4、5、12……。
这就是分页管理，第一张纸叫页表。你要复习哪一门课，就到页表里查寻相关的纸的编号，然后翻到那一页去复习
 

####5.页面置换算法

+ 先进先出法（FIFO）：（置换次数比较多）
+ 最佳置换法（OPT）：选择将来不再使用或在最远的将来才被访问的页调换出去（不便于实现）
+ 最近最少使用置换法（LRU）:当需要置换一页时，选择在最近一段时间里最久没有使用过的页面予以淘汰
+ 最近未使用置换法（NUR）：是LRU算法的近似方法，选择在最近一段时间里未被访问过的页面予以淘汰


####6.磁盘移臂调度算法

+ 1） 先来先服务算法； (根据访问者提出访问请求的先后次序来决定执行次序。)
+ 2） 最短寻找时间优先调度算法；(从等待的访问者中挑选寻找时间最短的那个请求执行，而不管访问者的先后次序。)
+ 3） 电梯调度算法；(从移动臂当前位置沿移动方向选择最近的那个柱面的访问者来执行，若该方向上无请求访问时，就改变移动方向再选择。)【减少移动臂移动所花的时间】
+ 4） 单向扫描调度算法。 (从0柱面开始往里单向扫描，扫到哪个执行哪个。然后再回到0柱面再往里扫
+ 5） 双向扫描调度算法。（从0柱面开始往里扫描，扫到最后一个时不需要返回0柱面，而直接换方向扫描，直至扫到0柱面）


####7.系统内存分类

















