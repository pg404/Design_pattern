##数据库

####关系模型术语
关系模型约定：属性具有原子性，即每个属性都是基本的数据类型；  
关系：二维表；  
属性：每列为一个属性；  
元组：每一行为一个元组，即记录；  
分量（component）：元组的每个属性值就是一个分量；  
表模式：由表名、表的属性、属性的数据类型组成；  
数据库模式：多个表的模式；  
域：属性的数据类型；  
实例：表就是关系的实例，当然，如果随着时间的改变，表发生改变，但是他仍然是关系的实例；  
当前实例：当前表的数据集；  
超键：能够确定一个元组的属性集；  
候选键：最小的超键；  
主键：设计者选定的候选键；  
主属性：构成候选键的属性，包含于候选码的一个属性；比如如果候选码为AB,则主属性可以是A，B，只要包含于候选码的单个属性即可


####关系型数据库和非关系型数据库的区别

#####关系型数据库（如Mysql和Oracle）

表和表、表和字段、数据和数据存在着关系

优点:

1.数据之间有关系，进行数据的增删改查的时候是非常方便的

2.关系型数据库是有事务操作的，保证数据的完整性和一致性。

缺点：

1.因为数据和数据是有关系的，底层是运行了大量的算法

大量算法会降低系统的效率，会降低性能

2.面对海量数据的增删改查的时候会显的无能为力

3.海量数据对数据进行维护变得非常的无力

>适合处理一般量级的数据（银行转账和钱）

#####非关系数据库的（如redis和MangDB）

为了处理海量数据，非关系数据库设计之初就是为了替代关系型数据库的关系

优点：

1.海量数据的增删改查是可以的

2.海量数据的维护和处理非常轻松

缺点：

1.数据和数据没有关系，他们之间就是单独存在的

2.非关系数据库没有关系，没有强大的事务关系，没有保证数据的完整性和安全性

>适合处理海量数据，保证效率，不一定安全（统计数据，例如微博数据）






####1.数据库中的"事务处理"指的是什么？
Transaction 事务是一系列在共享数据库上执行的行为，以达到更高层次更复杂逻辑的功能。事务是DBMS中最基础的单位，事务不可分割

事务时数据库中的一个单独的执行单元（unit），它通常由高级数据库操作语言或者编程语言编写的用户程序的执行所引起。当在数据库中更改数据成功时，在事务中更改的数据便会提交，否则，事务就取消或者回滚，更改无效。

####2.事务的四个特性
[https://blog.csdn.net/u013007900/article/details/77927723]

[https://blog.csdn.net/shuaihj/article/details/14163713]


ACID，是指在可靠数据库管理系统（DBMS）中，事务(transaction)所应该具有的四个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）

**原子性:**  

原子性是指事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生。
事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样

**一致性:**  

一致性是指事务使得系统从一个一致的状态转换到另一个一致状态。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性

>事务的一致性决定了一个系统设计和实现的复杂度。事务可以不同程度的一致性：  
 强一致性：读操作可以立即读到提交的更新操作。  
 弱一致性：提交的更新操作，不一定立即会被读操作读到，此种情况会存在一个不一致窗口，指的是读操作可以读到最新值的一段时间。  
 最终一致性：是弱一致性的特例。事务更新一份数据，最终一致性保证在没有其他事务更新同样的值的话，最终所有的事务都会读到之前事务更新的最新值。如果没有错误发生，不一致窗口的大小依赖于：通信延迟，系统负载等。  
 
 >其他一致性变体还有：  
 单调一致性：如果一个进程已经读到一个值，那么后续不会读到更早的值。  
 会话一致性：保证客户端和服务器交互的会话过程中，读操作可以读到更新操作后的最新值


**隔离性:**  

多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。

这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离

并行时可能出现的问题：  
>脏读：事务A修改了一个数据，但未提交，事务B读到了事务A未提交的更新结果，如果事务A提交失败，事务B读到的就是脏数据。  
不可重复读：在同一个事务中，对于同一份数据读取到的结果不一致。比如，事务B在事务A提交前读到的结果，和提交后读到的结果可能不同。  
幻读：在同一个事务中，同一个查询多次返回的结果不一致。事务A新增了一条记录，事务B在事务A提交前后各执行了一次查询操作，发现后一次比前一次多了一条记录  

不同的隔离级别：
>Read Uncommitted：最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都会发生。  
 Read Committed：只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题。  
 Repeated Read：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。  
 Serialization：事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题  
 
**持久性：**

持久性，意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。

即使出现了任何事故比如断电等，事务一旦提交，则持久化保存在数据库中


####3.索引

#####索引的优点
索引加快数据库的检索速度  
索引降低了插入、删除、修改等维护任务的速度  
唯一索引可以确保每一行数据的唯一性  
通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能  
索引需要占物理和数据空间  

#####使用索引查询一定能提高查询的性能吗？为什么
通常,通过索引查询数据比全表扫描要快.但是我们也必须注意到它的代价.  
      
索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时,索引本身也会被修改. 这意味着每条记录的INSERT,DELETE,UPDATE将为此多付出4,5 次的磁盘I/O. 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.使用索引查询不一定能提高查询性能,索引范围查询(INDEX RANGE SCAN)适用于两种情况:
      
   基于一个范围的检索,一般查询返回结果集小于表中记录数的30%
   
   基于非唯一性索引的检索


#####聚集索引和非聚集索引的区别
>其实，我们的汉语字典的正文本身就是一个聚集索引。比如，我们要查“安”字，就会很自然地翻开字典的前几页，因为“安”的拼音是“an”，而按照拼音排序汉字的字典是以英文字母“a”开头并以“z”结尾的，那么“安”字就自然地排在字典的前部。如果您翻完了所有以“a”开头的部分仍然找不到这个字，那么就说明您的字典中没有这个字；同样的，如果查“张”字，那您也会将您的字典翻到最后部分，因为“张”的拼音是“zhang”。也就是说，字典的正文部分本身就是一个目录，您不需要再去查其他目录来找到您需要找的内容。我们把这种正文内容本身就是一种按照一定规则排列的目录称为“聚集索引”。

>如果您认识某个字，您可以快速地从自动中查到这个字。但您也可能会遇到您不认识的字，不知道它的发音，这时候，您就不能按照刚才的方法找到您要查的字，而需要去根据“偏旁部首”查到您要找的字，然后根据这个字后的页码直接翻到某页来找到您要找的字。但您结合“部首目录”和“检字表”而查到的字的排序并不是真正的正文的排序方法，比如您查“张”字，我们可以看到在查部首之后的检字表中“张”的页码是672页，检字表中“张”的上面是“驰”字，但页码却是63页，“张”的下面是“弩”字，页面是390页。很显然，这些字并不是真正的分别位于“张”字的上下方，现在您看到的连续的“驰、张、弩”三字实际上就是他们在非聚集索引中的排序，是字典正文中的字在非聚集索引中的映射。我们可以通过这种方式来找到您所需要的字，但它需要两个过程，先找到目录中的结果，然后再翻到您所需要的页码。我们把这种目录纯粹是目录，正文纯粹是正文的排序方式称为“非聚集索引”。



####4.范式【Normal Form】

[https://blog.csdn.net/SevenGirl2017/article/details/77678233]

范化是在识别数据库中的数据元素，关系，以及定义所需的表和各表中的项目这些初始工作之后的一个细化的过程。

目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。

范式越高，冗余最低，一般到三范式，再往上，表越多，可能导致查询效率下降。所以有时为了提高运行效率，可以让数据冗余(反三范式，一般某个数据经常被访问时，比如数据表里存放了语文数学英语成绩，但是如果在某个时间经常要得到它的总分，每次都要进行计算会降低性能，可以加上总分这个冗余字段)。

后面的范式是在满足前面范式的基础上，比如满足第二范式的一定满足第一范式


第一范式（1NF）：确保每一列的原子性  
>每个关系r的属性值为不可分的原子值

如果每一列都是不可再分的最小数据单元，则满足第一范式

第二范式（2NF）:非键字段必须依赖于键字段  
> 满足1NF，非主属性完全函数依赖于候选键(左部不可约)

如果一个关系满足1NF，并且除了主键以外的其它列，都依赖与该主键，则满足二范式(2NF)，第二范式要求每个表只描述一件事

第三范式（3NF)：在1NF基础上，除了主键以外的其它列都不传递依赖于主键列，或者说： 任何非主属性不依赖于其它非主属性
（在2NF基础上消除传递依赖）
>满足2NF，消除非主属性对候选键的传递依赖

BCNF构建在第三范式的基础上，如果关系模式R是第一范式，且每个属性都不传递依赖于R的候选键，那么称R为BCNF的模式。
>满足3NF，消除每一属性对候选键的传递依赖


####5.Drop、delete与truncate分别在什么场景之下使用？

不再需要一张表的时候，用drop  
想删除部分数据行时候，用delete，并且带上where子句  
保留表而删除所有数据的时候用truncate  

      

####6.数据库的乐观缩和悲观锁
[https://blog.csdn.net/samjustin1/article/details/52210125]

[https://blog.csdn.net/aluomaidi/article/details/52460844]

数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。

乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。

悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作  
乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。

