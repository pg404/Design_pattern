###软件工程

软件工程是： 
（1）将系统化的、规范化、可量化的方法应用于软件的开发、运行和维护，即将工程化方法应用于软件。 
（2）在（1）中所述方法的研究


####1.黑盒测试&白盒测试

*黑盒测试* ：  
从外部观察测试对象，将其看做是一个不了解其内容的闭盒或黑盒，那么，我们的测试就是向闭盒提供输入数据，并记录产生的输出。  
从用户的观点，按规格说明书要求的输入数据与输出数据的对应关系设计测试用例，是根据程序外部特征进行测试。     

*白盒测试* ：  
将测试对象看成是一个开盒（透明盒）或白盒，然后可以根据测试对象的结构用不同的方式来进行测试。  
根据程序内部逻辑结构进行测试

####2.耦合与内聚
耦合：两个软件部件之间的相互关联程度

内聚：软件部件内部的关联程度

####3.极限编程 & 派对编程
极限编程（XP）是一种轻量级的软件开发方法论，属于敏捷开发方法。XP从实践中来，是对实践的总结，也是经过实践检验的，其主要特征是要适应环境变化和需求变化，充分发挥开发人员的主动精神。XP承诺降低软件项目风险，改善业务变化的反应能力，提高开发期间的生产力，为软件开发过程增加乐趣等等 。

派对编程属于主要的敏捷开发方法，其开发方式是两个程序员共同开发程序，且角色分工明确。一个负责编写程序，另一个负责复审与测试。两人定期交换角色。

####4.单元测试、系统测试、回归测试
单元测试：检查集成的系统是否按照需求中指定的那样执行它的功能  

系统测试：步骤

1.     功能测试：系统是否按照需求中指定的那样执行它的功能

2.     性能测试：软件与非功能系统需求进行比较

3.     验收测试：根据用户的需求描述检查系统

4.      安装测试：保证系统按照它应有的方式进行

回归测试：是用于新的版本或发布的一种测试，以验证与旧版本或发布相比，它是否以同样的方式执行相同的功能


####5.Process Model

惯用过程模型是为了改变软件开发的混乱状态，促使软件开发更加有序。

#####(1)瀑布模型（waterfall model）：

又被称为经典生命周期（classic life cycle），它提出了一个系统的、顺序的软件开发方法。 
   
   优点：   
   有利于大型软件开发过程中人员的组织、管理，从而提高了大型软件项目开发的质量和效率。 
   当需求确定、工作采用线性的方式完成的时候瀑布模型是一个很有用的过程模型。 
   一个有用的过程模型，其中需求是固定的，工作将以线性方式完成。 
   
   缺点:   
   过于理想，缺乏灵活性，容易产生需求偏差。 
   实际的项目很少遵守瀑布模型提出的顺序。 
   客户通常很难清除的描述所有的需求。 
   客户必须要有耐心，因为只有在项目接近尾声的时候，他们才能的带执行的程序。 
   
   适用范围：需求确定，工作能够采用线性的方式完成的软件。 
   
#####(2)V模型（V-model）： 
   
   描述了质量保证动作同沟通、建模相关动作以及早期构建相关的动作之间的关系。 
   V模型强调软件开发的协作和速度，将软件实现和验证有机地结合起来，在保证较高的软件质量情况下缩短开发周期。 
   
   优点：适合工程量小、人力资源少并且开发过程中改动不大的项目 
   
   缺点：错误发现时间迟，产生的风险代价高 

#####(3)增量过程模型（Incremental Model） 
   
   增量过程模型侧重于每一个增量都提交一个可以运行的产品。   
   
   优点：   
   1.能在较短的时间内向用户提交可完成部分工作的产品。   
   2.逐步增加产品功能可以使用户有充裕的时间学习和适应新产品，从而减少一个 全新的软件可能给客户组织带来的冲击。  
   3. 规避技术风险   
   4. 可并行开发构件，加快开发的进度   
   5. 对于在业务截止日期之前完全实施的人员配置非常有用。   
   
   缺点：   
   （1）并行开发构件有可能遇到不能集成的风险，软件必须具备开放式的体系结构；   
   （2）增量模型的灵活性可以使其适应这种变化的能力大大优于瀑布模型和快速原型模型，但也很容易退化为边做边改模型，从而是软件过程的控制失去整体性。 
   
   适用范围：   
   （1）进行已有产品升级或新版本开发，增量模型是非常适合的；   
   （2）对完成期限严格要求的产品，可以使用增量模型；   
   （3）对所开发的领域比较熟悉而且已有原型系统，增量模型也是非常适合的。   
   （4） 项目在既定的商业要求期限之前不可能找到足够的开发人员 

#####(4)原型开发（prototyping ）：

当需求很模糊的时候，原型开发可以帮助软件开发人员和利益相关者更好地理解究竟需要做什么。 
   
   优点：   
   开发者与用户充分交流，可以澄清模糊需求，需求定义比其他 模型好得多   
   开发过程与用户培训过程同步   
   为用户需求的改变提供了充分的余地   
   开发风险低，产品柔性好   
   开发费用低，时间短   
   系统易维护，对用户更友好  
   
   缺点：   
   1、 没有考虑软件的整体质量和长期的可维护性。   
   2、 大部分情况是不合适的操作算法被采用目的为了演示功能，不合适的开发工 具被采用仅仅为了它的方便，还有不合适的操作系统被选择等等。   
   3、 由于达不到质量要求产品可能被抛弃，而采用新的模型重新设计。   
   
   适用范围：   
   尽管原型可以用作独立的流程模型，但它更常用作一种可以在任何流模型的上下文中实现的技术。 

#####(5)螺旋模型（Spiral Model） 

   螺旋模型是一种风险驱动型的过程模型生成器，对于软件集中的系统，它可以指导多个利益相关者的协同工作。 
   
   优点： 
   它结合了原型的迭代性质和瀑布模型的系统性和可控性特点。 
   1. 强调风险 
   2. 强调阶段质量 
   3. 提供纠错的机会 
   4. 使用原型作为风险降低机制，进一步使开发人员能够在产品演变的任何阶段应用原型方法。 
   
   缺点： 
   1. 每个阶段都要提出被选方案，进行风险分析，研发周期长，效率低 
   2. 必须要转业的风险分析人员的参与 
   3. 如果没有发现和管理重大风险，问题无疑将会发生。 
   
   适用范围：大型项目 

#####(6)协同模型（main.java.concurrent development model） 

   有时候又称为协同工程，它允许软件团队表述本章所描述的任何模型中的迭代和并发元素。 
   协同建模提供了项目当前状态的准确画面。 
   
   适用范围：所有类型的软件开发，协同模型通常更适合涉及不同工程团队的产品工程项目。
   
#####(7)统一过程（Unified Process） 
   统一过程模型  
    
   统一过程模型是一种“用例驱动、以体系结构为核心、迭代及增量”的软件 过程框架，由 UML 方法和工具支持。
   它是一种增量模型，定义了五个阶段：   
   a、起始阶段，包括用户沟通和计划活动，强调定义和细化用例   
   b、细化阶段，包括用户沟通和建模活动，重点是创建分析和设计模型。   
   c、构件阶段，细化模型设计，并将设计模型转化为软件构件实现   
   d、 转化阶段，将软件从开发人员传递给最终用户，并由用户完成 beta 测试和验收测试   
   e、生产阶段，持续地监控软件的运行，并提供技术支持。 
   
   优点：   
   1. 任何功能开发后就进入测试过程，及早进行验证 
   2. 早期风险识别，采取预防措施
   
   缺点： 
   1. 需求必须在开始之前完全弄清楚，否怎有可能在架构上出现错误   
   2. 必须有严格的过程管理，以免使过程退化为原始的试→错→改模式   
   3. 如果不加控制的让用户过早接触没有测试完全，版本不稳定的产品可能对用户和开发团队都带来负面的影响


####6. 基本设计原则

开闭原则（Open-Closed Principle ，OCP）：模块应该对外延具有开放性，对修改具有封闭性。   
依赖倒置原则（Dependency Inversion Principle ，DIP）：依赖于抽象，而非具体实现。  
Liskov替换原则（Liskov Substitution Principle (LSP)）：子类可以替换他们的基类。   
接口分离原则（The Interface Segregation Principle (ISP)）：多个客户专用接口比一个通用接口好   
发布复用等价性原则（The Release Reuse Equivalency Principle，REP）：复用的粒度就是发布的粒度   
共同封装原则（The Common Closure Principle (CCP)）：一同变更的类应该合在一起   
共同复用原则（The Common Reuse Principle (CRP））：不能一起复用的类不能被分到一组  


####7.内聚性
内聚性（Cohesion）：内聚性意味着构件或者类只封装那些相互关联密切，以及与构件或类自身有亲密关系的属性和操作。 

功能内聚：主要通过操作来体现，当一个模块只完成某一组特定操作并返回结果时，就称此模块是功能内聚的。   
分层内聚：高层能够访问低层的服务，但低层不能访问高层的服务。   
通信内聚：访问相同数据的所有操作被定义在同一个类中。（数据的查询，访问，存储）  

####8.耦合性
耦合是类之间彼此联系程度的一种定性度量。 
随着类（构件）相互依赖越来越多，类之间的耦合程度亦会增加。 

内容耦合：暗中修改其他构件的内部数据，这违反了信息隐蔽原则   
公用耦合：当大量的构件都要使用同一个全局变量时发生这种耦合   
控制耦合：当操作A调用操作B，并向B传递控制标记时，就会发生这种耦合。   
标记耦合：当类B被声明为类A某一操作中的一个参数类型时，就会发生这种耦合。   
数据耦合：当操作需要传递长串的数据参数时，就会发生这种耦合。   
例程调用耦合：当一个操作调用另一个操作时，就会发生这种耦合。   
类型使用耦合：当构件A使用了在构件B中定义的一个数据类型时，就会发生这种耦合。   
包含或者导入耦合：当构件A引入或者包含一个构件B的包或者内容时，就会发生这种耦合。   
外部耦合：当一个构件和基础设施构件进行通信和协作时，就会发生这种耦合。  

####9.高内聚低耦合
　为什么要高内聚?  
　　 
　模块之间的关系越紧密,出错就越少! 

　为什么要低耦合?　  
　 
　子程序间的关系越复杂,就会产生更多的意想不到的错误!会给以后的维护工作带来很多麻烦! 
　 
>高内聚低耦合，是软件工程中的概念，是判断设计好坏的标准，主要是面向对象的设计，主要是看类的内聚性是否高，耦合度是否低。

####10.单元测试

单元测试侧重于软件设计的最小单元（软件构件或模块）的验证工作。   
单元测试侧重于构件的内部处理逻辑和数据结构。   
可以对多个构件并行执行。   
测试模块的接口是为了保证被测试程序单元的信息能够正常地流入和流出；   
检查局部数据结构以确保临时存储的数据在算法的整个执行过程中能维持其完善性。   
执行控制结构中的所有独立路径（基本路径）以确保模块中的所有语句至少执行一次。   
测试边界条件确保模块在到达边界值得极限或受限处理的情形下仍能正确执行。   
最后要对所有的错误处理路径进行测试。  


####11.集成测试

集成测试时构造软件体系结构的系统化技术，同时也是进行一些旨在发现与接口相关的错误的测试。 
集成测试的目标是利用单元测试的构件建立设计中描述的程序结构。

自顶向下集成：  

自顶向下集成测试是一种构造软件体系结构的增量方法。   

深度优先：深度优先集成是首先集成位于程序结构中主控路径上的所有控件。   
广度优先：广度优先集成首先沿水平方向，将属于同一层的构件集成起来。   

自顶向下集成过程：   
1.主控模块作为测试驱动模块，用桩模块代替直接附属的下层模块；   
2.根据所选的集成策略（深度优先/广度优先），每次用一个实际模块替换一个桩模块；   
3.每集成一个模块都进行测试；   
4.完成每个测试集之后，用实际模块替换另一个桩模块；   
5.可以进行回归测试（即全部或部分地重复已做过的测试），以避免引入新错误。 
回到第2步继续执行此过程，直到完成整个程序结构的构造。  

自底向上集成测试：

就是从原子模块（程序结构的最底层构件）开始进行构造和测试。 

自底向上集成测试过程：   
1.连接底层构件以构成完成特定子功能的簇。   
2.编写驱动模块（测试的控制程序）以协调测试用例的输入和输出   
3.测试簇   
4.去掉驱动程序，沿着程序结构向上逐步连接簇   

####12回归测试
回归测试重新执行已测试过的某些子集，以确保变更没有传播不期望的副作用。   
回归测试有助于保证变更不引入无意思行为或额外的错误。   
回归测试可以手工进行，方法是重新执行所以测试用例的子集，或者利用捕捉/回放工具自动进行  

####13.系统测试
系统测试实际上是对整个基于计算机的系统进行一系列不同考验的测试。所有测试都是为了验证系统成分已经正确地集成在一起，并且完成了指派的功能。

恢复测试（Recovery testing）:通过各种方式强制让软件以各种方式失败并验证恢复是否正确执行。   
安全测试（Security testing）：安全测试验证建立在系统内的保护机制是否能够实际保护系统不受非法入侵。   
压力测试（Stress testing）：压力测试的目的是是软件面对非正常的情形。是一种要求以非正常数量、频率或容量的方式进行彻底评估。   
性能测试（Performance testing）：性能测试用来测试软件在集成环境中的运行性能。   
部署测试（Deployment testing）：部有时也将署测试称为配置测试，是在软件将要在其中运行的每一种环境中测试软件。  

####14.白盒测试
白盒测试：白盒测试有时也称为玻璃盒测试，是一种测试用例设计方法，它利用作为构件层设计的一部分描述的控制结构来生成测试用例。 

白盒测试是在了解模块内部结构的情况下进行的测试。 
利用白盒测试方法导出的测试用例可以：   
（1）保证一个模块中的所有独立路径至少被执行一次。   
（2）对所有的逻辑判定均需要测试取真和取假两个方面。   
（3）在上下边界及可操作的范围内执行所有的循环。   
（4）检验内部数据结构以确保其有效性。  


####15.黑盒测试
黑盒测试也称为行为测试，侧重软件的功能需求。   
黑盒测试使软件工程师能设计出将测试程序所有功能需求的输入条件集。   
黑盒测试不是白盒测试的替代品，而是作为发现其他类型错误的辅助方法。   

黑盒测试试图发现以下类型的错误：   
（1）不正确或遗漏的功能   
（2）接口错误   
（3）数据用在测试的后期阶段   
（4）行为或性能错误   
（5）初始化和终止错误   

黑盒测试的方法：   
Graph-based testing methods 基于图的测试方法   
Equivalence partitioning 等价类划分   
Boundary value analysis 边界值分析   
Orthogonal array testing 正交数组测试  




